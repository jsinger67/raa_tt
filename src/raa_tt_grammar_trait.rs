// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait RaaTtGrammarTrait<'t> {
    /// Semantic action for non-terminal 'Not'
    fn not(&mut self, _arg: &Not<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'And'
    fn and(&mut self, _arg: &And<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Or'
    fn or(&mut self, _arg: &Or<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Cond'
    fn cond(&mut self, _arg: &Cond<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BiCond'
    fn bi_cond(&mut self, _arg: &BiCond<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LPar'
    fn l_par(&mut self, _arg: &LPar<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RPar'
    fn r_par(&mut self, _arg: &RPar<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Var'
    fn var(&mut self, _arg: &Var<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RaaTt'
    fn raa_tt(&mut self, _arg: &RaaTt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Biconditional'
    fn biconditional(&mut self, _arg: &Biconditional<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Conditional'
    fn conditional(&mut self, _arg: &Conditional<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Disjunction'
    fn disjunction(&mut self, _arg: &Disjunction<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Conjunction'
    fn conjunction(&mut self, _arg: &Conjunction<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Negation'
    fn negation(&mut self, _arg: &Negation<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 24
///
/// `Factor: Var;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorVar<'t> {
    pub var: Var<'t>,
}

///
/// Type derived for production 25
///
/// `Factor: Negation;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorNegation<'t> {
    pub negation: Box<Negation<'t>>,
}

///
/// Type derived for production 26
///
/// `Factor: LPar^ /* Clipped */ Biconditional RPar^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorLParBiconditionalRPar<'t> {
    pub biconditional: Box<Biconditional<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal And
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct And<'t> {
    pub and: Token<'t>, /* & */
}

///
/// Type derived for non-terminal BiCond
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BiCond<'t> {
    pub bi_cond: Token<'t>, /* <-> */
}

///
/// Type derived for non-terminal Biconditional
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Biconditional<'t> {
    pub conditional: Conditional<'t>,
    pub biconditional_list: Vec<BiconditionalList<'t>>,
}

///
/// Type derived for non-terminal BiconditionalList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BiconditionalList<'t> {
    pub conditional: Conditional<'t>,
}

///
/// Type derived for non-terminal Cond
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Cond<'t> {
    pub cond: Token<'t>, /* -> */
}

///
/// Type derived for non-terminal Conditional
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Conditional<'t> {
    pub disjunction: Disjunction<'t>,
    pub conditional_list: Vec<ConditionalList<'t>>,
}

///
/// Type derived for non-terminal ConditionalList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConditionalList<'t> {
    pub disjunction: Disjunction<'t>,
}

///
/// Type derived for non-terminal Conjunction
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Conjunction<'t> {
    pub factor: Factor<'t>,
    pub conjunction_list: Vec<ConjunctionList<'t>>,
}

///
/// Type derived for non-terminal ConjunctionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConjunctionList<'t> {
    pub factor: Factor<'t>,
}

///
/// Type derived for non-terminal Disjunction
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Disjunction<'t> {
    pub conjunction: Conjunction<'t>,
    pub disjunction_list: Vec<DisjunctionList<'t>>,
}

///
/// Type derived for non-terminal DisjunctionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DisjunctionList<'t> {
    pub conjunction: Conjunction<'t>,
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor<'t> {
    Var(FactorVar<'t>),
    Negation(FactorNegation<'t>),
    LParBiconditionalRPar(FactorLParBiconditionalRPar<'t>),
}

///
/// Type derived for non-terminal LPar
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LPar<'t> {
    pub l_par: Token<'t>, /* ( */
}

///
/// Type derived for non-terminal Negation
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Negation<'t> {
    pub factor: Factor<'t>,
}

///
/// Type derived for non-terminal Not
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Not<'t> {
    pub not: Token<'t>, /* ! */
}

///
/// Type derived for non-terminal Or
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Or<'t> {
    pub or: Token<'t>, /* | */
}

///
/// Type derived for non-terminal RPar
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RPar<'t> {
    pub r_par: Token<'t>, /* ) */
}

///
/// Type derived for non-terminal RaaTt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RaaTt<'t> {
    pub raa_tt_list: Vec<RaaTtList<'t>>,
}

///
/// Type derived for non-terminal RaaTtList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RaaTtList<'t> {
    pub biconditional: Biconditional<'t>,
}

///
/// Type derived for non-terminal Var
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Var<'t> {
    pub var: Token<'t>, /* [a-z][_a-zA-Z0-9]* */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    And(And<'t>),
    BiCond(BiCond<'t>),
    Biconditional(Biconditional<'t>),
    BiconditionalList(Vec<BiconditionalList<'t>>),
    Cond(Cond<'t>),
    Conditional(Conditional<'t>),
    ConditionalList(Vec<ConditionalList<'t>>),
    Conjunction(Conjunction<'t>),
    ConjunctionList(Vec<ConjunctionList<'t>>),
    Disjunction(Disjunction<'t>),
    DisjunctionList(Vec<DisjunctionList<'t>>),
    Factor(Factor<'t>),
    LPar(LPar<'t>),
    Negation(Negation<'t>),
    Not(Not<'t>),
    Or(Or<'t>),
    RPar(RPar<'t>),
    RaaTt(RaaTt<'t>),
    RaaTtList(Vec<RaaTtList<'t>>),
    Var(Var<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct RaaTtGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn RaaTtGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `RaaTtGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> RaaTtGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn RaaTtGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `Not: '!';`
    ///
    #[parol_runtime::function_name::named]
    fn not(&mut self, not: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let not = not.token()?.clone();
        let not_built = Not { not };
        // Calling user action here
        self.user_grammar.not(&not_built)?;
        self.push(ASTType::Not(not_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `And: '&';`
    ///
    #[parol_runtime::function_name::named]
    fn and(&mut self, and: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let and = and.token()?.clone();
        let and_built = And { and };
        // Calling user action here
        self.user_grammar.and(&and_built)?;
        self.push(ASTType::And(and_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `Or: '|';`
    ///
    #[parol_runtime::function_name::named]
    fn or(&mut self, or: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or = or.token()?.clone();
        let or_built = Or { or };
        // Calling user action here
        self.user_grammar.or(&or_built)?;
        self.push(ASTType::Or(or_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `Cond: '->';`
    ///
    #[parol_runtime::function_name::named]
    fn cond(&mut self, cond: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let cond = cond.token()?.clone();
        let cond_built = Cond { cond };
        // Calling user action here
        self.user_grammar.cond(&cond_built)?;
        self.push(ASTType::Cond(cond_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `BiCond: '<->';`
    ///
    #[parol_runtime::function_name::named]
    fn bi_cond(&mut self, bi_cond: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bi_cond = bi_cond.token()?.clone();
        let bi_cond_built = BiCond { bi_cond };
        // Calling user action here
        self.user_grammar.bi_cond(&bi_cond_built)?;
        self.push(ASTType::BiCond(bi_cond_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `LPar: '(';`
    ///
    #[parol_runtime::function_name::named]
    fn l_par(&mut self, l_par: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_par = l_par.token()?.clone();
        let l_par_built = LPar { l_par };
        // Calling user action here
        self.user_grammar.l_par(&l_par_built)?;
        self.push(ASTType::LPar(l_par_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `RPar: ')';`
    ///
    #[parol_runtime::function_name::named]
    fn r_par(&mut self, r_par: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_par = r_par.token()?.clone();
        let r_par_built = RPar { r_par };
        // Calling user action here
        self.user_grammar.r_par(&r_par_built)?;
        self.push(ASTType::RPar(r_par_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `Var: /[a-z][_a-zA-Z0-9]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn var(&mut self, var: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var = var.token()?.clone();
        let var_built = Var { var };
        // Calling user action here
        self.user_grammar.var(&var_built)?;
        self.push(ASTType::Var(var_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `RaaTt: RaaTtList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn raa_tt(&mut self, _raa_tt_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raa_tt_list = pop_and_reverse_item!(self, raa_tt_list, RaaTtList, context);
        let raa_tt_built = RaaTt { raa_tt_list };
        // Calling user action here
        self.user_grammar.raa_tt(&raa_tt_built)?;
        self.push(ASTType::RaaTt(raa_tt_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `RaaTtList /* Vec<T>::Push */: Biconditional RaaTtList;`
    ///
    #[parol_runtime::function_name::named]
    fn raa_tt_list_0(
        &mut self,
        _biconditional: &ParseTreeType<'t>,
        _raa_tt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut raa_tt_list = pop_item!(self, raa_tt_list, RaaTtList, context);
        let biconditional = pop_item!(self, biconditional, Biconditional, context);
        let raa_tt_list_0_built = RaaTtList { biconditional };
        // Add an element to the vector
        raa_tt_list.push(raa_tt_list_0_built);
        self.push(ASTType::RaaTtList(raa_tt_list), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `RaaTtList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn raa_tt_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raa_tt_list_1_built = Vec::new();
        self.push(ASTType::RaaTtList(raa_tt_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `Biconditional: Conditional BiconditionalList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn biconditional(
        &mut self,
        _conditional: &ParseTreeType<'t>,
        _biconditional_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let biconditional_list =
            pop_and_reverse_item!(self, biconditional_list, BiconditionalList, context);
        let conditional = pop_item!(self, conditional, Conditional, context);
        let biconditional_built = Biconditional {
            conditional,
            biconditional_list,
        };
        // Calling user action here
        self.user_grammar.biconditional(&biconditional_built)?;
        self.push(ASTType::Biconditional(biconditional_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `BiconditionalList /* Vec<T>::Push */: BiCond^ /* Clipped */ Conditional BiconditionalList;`
    ///
    #[parol_runtime::function_name::named]
    fn biconditional_list_0(
        &mut self,
        _bi_cond: &ParseTreeType<'t>,
        _conditional: &ParseTreeType<'t>,
        _biconditional_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut biconditional_list =
            pop_item!(self, biconditional_list, BiconditionalList, context);
        let conditional = pop_item!(self, conditional, Conditional, context);
        self.pop(context);
        let biconditional_list_0_built = BiconditionalList { conditional };
        // Add an element to the vector
        biconditional_list.push(biconditional_list_0_built);
        self.push(ASTType::BiconditionalList(biconditional_list), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `BiconditionalList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn biconditional_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let biconditional_list_1_built = Vec::new();
        self.push(
            ASTType::BiconditionalList(biconditional_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `Conditional: Disjunction ConditionalList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn conditional(
        &mut self,
        _disjunction: &ParseTreeType<'t>,
        _conditional_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let conditional_list =
            pop_and_reverse_item!(self, conditional_list, ConditionalList, context);
        let disjunction = pop_item!(self, disjunction, Disjunction, context);
        let conditional_built = Conditional {
            disjunction,
            conditional_list,
        };
        // Calling user action here
        self.user_grammar.conditional(&conditional_built)?;
        self.push(ASTType::Conditional(conditional_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `ConditionalList /* Vec<T>::Push */: Cond^ /* Clipped */ Disjunction ConditionalList;`
    ///
    #[parol_runtime::function_name::named]
    fn conditional_list_0(
        &mut self,
        _cond: &ParseTreeType<'t>,
        _disjunction: &ParseTreeType<'t>,
        _conditional_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut conditional_list = pop_item!(self, conditional_list, ConditionalList, context);
        let disjunction = pop_item!(self, disjunction, Disjunction, context);
        self.pop(context);
        let conditional_list_0_built = ConditionalList { disjunction };
        // Add an element to the vector
        conditional_list.push(conditional_list_0_built);
        self.push(ASTType::ConditionalList(conditional_list), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `ConditionalList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn conditional_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let conditional_list_1_built = Vec::new();
        self.push(ASTType::ConditionalList(conditional_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `Disjunction: Conjunction DisjunctionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn disjunction(
        &mut self,
        _conjunction: &ParseTreeType<'t>,
        _disjunction_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let disjunction_list =
            pop_and_reverse_item!(self, disjunction_list, DisjunctionList, context);
        let conjunction = pop_item!(self, conjunction, Conjunction, context);
        let disjunction_built = Disjunction {
            conjunction,
            disjunction_list,
        };
        // Calling user action here
        self.user_grammar.disjunction(&disjunction_built)?;
        self.push(ASTType::Disjunction(disjunction_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `DisjunctionList /* Vec<T>::Push */: Or^ /* Clipped */ Conjunction DisjunctionList;`
    ///
    #[parol_runtime::function_name::named]
    fn disjunction_list_0(
        &mut self,
        _or: &ParseTreeType<'t>,
        _conjunction: &ParseTreeType<'t>,
        _disjunction_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut disjunction_list = pop_item!(self, disjunction_list, DisjunctionList, context);
        let conjunction = pop_item!(self, conjunction, Conjunction, context);
        self.pop(context);
        let disjunction_list_0_built = DisjunctionList { conjunction };
        // Add an element to the vector
        disjunction_list.push(disjunction_list_0_built);
        self.push(ASTType::DisjunctionList(disjunction_list), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `DisjunctionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn disjunction_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let disjunction_list_1_built = Vec::new();
        self.push(ASTType::DisjunctionList(disjunction_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `Conjunction: Factor ConjunctionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn conjunction(
        &mut self,
        _factor: &ParseTreeType<'t>,
        _conjunction_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let conjunction_list =
            pop_and_reverse_item!(self, conjunction_list, ConjunctionList, context);
        let factor = pop_item!(self, factor, Factor, context);
        let conjunction_built = Conjunction {
            factor,
            conjunction_list,
        };
        // Calling user action here
        self.user_grammar.conjunction(&conjunction_built)?;
        self.push(ASTType::Conjunction(conjunction_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `ConjunctionList /* Vec<T>::Push */: And^ /* Clipped */ Factor ConjunctionList;`
    ///
    #[parol_runtime::function_name::named]
    fn conjunction_list_0(
        &mut self,
        _and: &ParseTreeType<'t>,
        _factor: &ParseTreeType<'t>,
        _conjunction_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut conjunction_list = pop_item!(self, conjunction_list, ConjunctionList, context);
        let factor = pop_item!(self, factor, Factor, context);
        self.pop(context);
        let conjunction_list_0_built = ConjunctionList { factor };
        // Add an element to the vector
        conjunction_list.push(conjunction_list_0_built);
        self.push(ASTType::ConjunctionList(conjunction_list), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `ConjunctionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn conjunction_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let conjunction_list_1_built = Vec::new();
        self.push(ASTType::ConjunctionList(conjunction_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `Negation: Not^ /* Clipped */ Factor;`
    ///
    #[parol_runtime::function_name::named]
    fn negation(&mut self, _not: &ParseTreeType<'t>, _factor: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor = pop_item!(self, factor, Factor, context);
        self.pop(context);
        let negation_built = Negation { factor };
        // Calling user action here
        self.user_grammar.negation(&negation_built)?;
        self.push(ASTType::Negation(negation_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `Factor: Var;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_0(&mut self, _var: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var = pop_item!(self, var, Var, context);
        let factor_0_built = FactorVar { var };
        let factor_0_built = Factor::Var(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `Factor: Negation;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_1(&mut self, _negation: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negation = pop_item!(self, negation, Negation, context);
        let factor_1_built = FactorNegation {
            negation: Box::new(negation),
        };
        let factor_1_built = Factor::Negation(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `Factor: LPar^ /* Clipped */ Biconditional RPar^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_2(
        &mut self,
        _l_par: &ParseTreeType<'t>,
        _biconditional: &ParseTreeType<'t>,
        _r_par: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let biconditional = pop_item!(self, biconditional, Biconditional, context);
        self.pop(context);
        let factor_2_built = FactorLParBiconditionalRPar {
            biconditional: Box::new(biconditional),
        };
        let factor_2_built = Factor::LParBiconditionalRPar(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for RaaTtGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item RaaTtGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.not(&children[0]),
            1 => self.and(&children[0]),
            2 => self.or(&children[0]),
            3 => self.cond(&children[0]),
            4 => self.bi_cond(&children[0]),
            5 => self.l_par(&children[0]),
            6 => self.r_par(&children[0]),
            7 => self.var(&children[0]),
            8 => self.raa_tt(&children[0]),
            9 => self.raa_tt_list_0(&children[0], &children[1]),
            10 => self.raa_tt_list_1(),
            11 => self.biconditional(&children[0], &children[1]),
            12 => self.biconditional_list_0(&children[0], &children[1], &children[2]),
            13 => self.biconditional_list_1(),
            14 => self.conditional(&children[0], &children[1]),
            15 => self.conditional_list_0(&children[0], &children[1], &children[2]),
            16 => self.conditional_list_1(),
            17 => self.disjunction(&children[0], &children[1]),
            18 => self.disjunction_list_0(&children[0], &children[1], &children[2]),
            19 => self.disjunction_list_1(),
            20 => self.conjunction(&children[0], &children[1]),
            21 => self.conjunction_list_0(&children[0], &children[1], &children[2]),
            22 => self.conjunction_list_1(),
            23 => self.negation(&children[0], &children[1]),
            24 => self.factor_0(&children[0]),
            25 => self.factor_1(&children[0]),
            26 => self.factor_2(&children[0], &children[1], &children[2]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment(token)
    }
}
